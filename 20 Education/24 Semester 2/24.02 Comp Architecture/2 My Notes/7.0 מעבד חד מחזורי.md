> [!toc] *Table of Contents*
> ```toc
## 1 רעיון בסיסי ומטרות
*   **הגדרה**: מימוש של מעבד MIPS (או תת-קבוצה שלו) שבו **כל פקודה** מתבצעת במחזור שעון **אחד** בלבד.
*   **מטרות לימודיות**: להבין כיצד ניתן לחבר את הרכיבים הבסיסיים (ALU, Register File, Memory, PC, Adders, Muxes) כדי ליצור Datapath (נתיב נתונים) ויחידת בקרה (Control Unit) המסוגלים לבצע פקודות מכונה. המודל שיוצג הוא פדגוגי ומפושט.
*   **הנחה מרכזית**: אורך מחזור השעון נקבע לפי הפקודה **האיטית ביותר** במערכת (הפקודה שלוקחת הכי הרבה זמן להתייצב דרך כל הרכיבים הקומבינטוריים).

## 2 תת-קבוצת פקודות למימוש
המעבד החד-מחזורי שנבנה יתמוך בתת-קבוצה מייצגת של פקודות MIPS:
*   **פעולות אריתמטיות/לוגיות (R-Type)**: `add`, `sub`, `and`, `or`, `slt`.
*   **גישה לזיכרון (I-Type)**: `lw`, `sw`.
*   **בקרת זרימה (I-Type, J-Type)**: `beq`, `j` (פקודת `j` תתווסף בהמשך).

## 3 שלבי ביצוע פקודה (High-level)
כל פקודה עוברת (באופן רעיוני, בתוך מחזור שעון אחד) דרך השלבים הבאים:

1.  ==Fetch==: הבאת הפקודה מהזיכרון (Instruction Memory) לפי הכתובת ב-**PC (Program Counter)**. חישוב הכתובת הבאה (`PC + 4`).
2.  ==Decode==: פיענוח הפקודה (זיהוי ה-Opcode, שדות הרגיסטרים, Immediate). קריאת ערכים נדרשים מקובץ הרגיסטרים (Register File).
3.  ==Execute==: ביצוע הפעולה הנדרשת ב-**ALU**:
    *   חישוב אריתמטי/לוגי (ב-R-Type).
    *   חישוב כתובת הזיכרון (ב-`lw`/`sw`): `Base + Offset`.
    *   חישוב תנאי ה-Branch והשוואה (ב-`beq`).
    *   חישוב כתובת היעד של ה-Branch (חישוב נפרד מה-ALU הראשי).
4.  ==Memory==: גישה לזיכרון הנתונים (Data Memory).
    *   קריאת נתון מהזיכרון (ב-`lw`).
    *   כתיבת נתון לזיכרון (ב-`sw`).
5.  ==Write Back==: כתיבת התוצאה (מה-ALU או מהזיכרון) חזרה לקובץ הרגיסטרים (בפקודות R-Type ו-`lw`).
> [!NOTE] שלבים משותפים ואופציונליים
> שלבי ה-Fetch וה-Decode משותפים לכל הפקודות. שלבי ה-Execute, Memory, Write Back הם אופציונליים ותלויים בסוג הפקודה.

![[SS 19052025 at 12.22.21 4.png]]
## 4 רכיבי ה-Datapath העיקריים
כדי לממש את השלבים הללו, נשתמש ברכיבים הבאים:

*   **PC (Program Counter)**: רגיסטר המחזיק את כתובת הפקודה הבאה לביצוע.
*   **Instruction Memory**: זיכרון לקריאה בלבד המכיל את הפקודות.
*   **Register File**: מקבץ האוגרים (32x32bit) עם 2 פורטי קריאה ו-1 פורט כתיבה.
*   **ALU (Arithmetic Logic Unit)**: מבצע פעולות אריתמטיות ולוגיות.
*   **Data Memory**: זיכרון לקריאה וכתיבה של נתונים.
*   **Adders**: לחישוב `PC+4` ולחישוב כתובת היעד של Branch.
*   **Sign Extend Unit**: להרחבת ה-Immediate מ-16 ל-32 סיביות (עם שמירת סימן).
*   **Shift Left 2**: להכפלת ההיסט של ה-Branch/Jump ב-4 (הזזה 2 שמאלה).
*   **Multiplexers (MUXes)**: לבחירת מקורות נתונים (למשל, לכניסה השנייה של ה-ALU, לנתון הנכתב ל-Register File, לכתובת ה-PC הבאה).
*   **Control Unit**: לוגיקה קומבינטורית המקבלת את ה-Opcode (ולפעמים ה-Funct) ומייצרת את כל אותות הבקרה ל-MUXים, ל-ALU, ולכתיבה לרגיסטרים/לזיכרון.

## 5 בניית ה-Datapath והבקרה

> [!IMPORTANT] עקרונות מנחים
>   * ניתן להשתמש בכל רכיב רק פעם אחת בפקודה.
> *   עקב כך, ==במידת הצורך חלק מהרכיבים ישוכפלו==, ע״מ שהשימוש בהם יהיה פעם אחת למחזור שעון.
> *   מחזור השעון של מעבד חד-מחזורי ייקבע ע''י נתיב הנתונים הארוך ביותר.
> *   זמן ביצוע פקודה יהיה החסם התחתון למחזור השעון (תדר השעון ייקבע גם הוא).
> * כל נתיבי הנתונים הללו משולבים יחד באמצעות MUXים הנשלטים ע"י יחידת הבקרה המרכזית, כדי שרק הנתיב הרלוונטי לפקודה הנוכחית יהיה פעיל בכל מחזור שעון.
### 5.1 נתיב ה-Fetch
*   PC מספק כתובת ל-IM.
*   IM מוציא את הפקודה.
*   Adder מחשב PC+4.

### 5.2 נתיב פקודות R-Type (`add`, `sub`, `and`, `or`, `slt`)
*   הפקודה מגיעה מה-IM.
*   שדות rs, rt נשלחים לפורטי הקריאה של ה-RF.
*   שדה rd נשלח לפורט הכתיבה של ה-RF (דרך MUX).
*   הנתונים מ-rs ו-rt נשלחים ל-ALU.
*   יחידת הבקרה (על סמך op=0 ו-funct) שולחת את קוד הפעולה המתאים ל-ALU.
*   תוצאת ה-ALU נשלחת לפורט ה-Write Data של ה-RF (דרך MUX).
*   יחידת הבקרה מפעילה את RegWrite=1 ואת RegDst=1 (לבחור ב-rd כיעד).

### 5.3 נתיב פקודות Load/Store (`lw`, `sw`)
*   שדה rs נשלח לפורט קריאה 1 של ה-RF (כתובת בסיס).
*   שדה rt נשלח לפורט קריאה 2 (עבור `sw`) או לפורט כתיבה (עבור `lw`, דרך MUX).
*   ה-Immediate (Offset) עובר Sign Extend ונשלח לכניסה השנייה של ה-ALU (דרך MUX, ALUSrc=1).
*   ה-ALU מבצע חיבור כדי לחשב את כתובת הזיכרון.
*   הכתובת נשלחת ל-Data Memory.
*   **עבור `lw`**:
    *   הבקרה מפעילה MemRead=1.
    *   הנתון הנקרא מה-DM נשלח לפורט ה-Write Data של ה-RF (דרך MUX, MemToReg=1).
    *   הבקרה מפעילה RegWrite=1 ו-RegDst=0 (לבחור ב-rt כיעד).
*   **עבור `sw`**:
    *   הנתון הנקרא מ-rt ב-RF נשלח לכניסת ה-Write Data של ה-DM.
    *   הבקרה מפעילה MemWrite=1. (RegWrite=0).

### 5.4 נתיב פקודת Branch (`beq`)
*   שדות rs, rt נשלחים לפורטי הקריאה של ה-RF.
*   הנתונים מ-rs ו-rt נשלחים ל-ALU.
*   הבקרה קובעת שה-ALU יבצע חיסור (ALUOp=01).
*   דגל ה-**Zero** מה-ALU נבדק.
*   במקביל, ה-Immediate (היסט) עובר Sign Extend ו-Shift Left 2.
*   Adder נוסף מחשב את כתובת היעד: `PC+4 + (immediate << 2)`.
*   יחידת הבקרה מקבלת את אות ה-Branch ואת דגל ה-Zero. אם שניהם 1, אות הבקרה **PCSrc** הופך ל-1.
*   MUX (הנשלט ע"י PCSrc) בוחר האם ה-PC הבא יהיה PC+4 או כתובת היעד שחושבה.

### 5.5 הוספת פקודת Jump (`j`)
*   נדרש MUX נוסף לפני ה-PC כדי לבחור בין PC+4, יעד ה-Branch, או יעד ה-Jump.
*   26 הסיביות התחתונות של הפקודה עוברות Shift Left 2.
*   4 הסיביות העליונות של PC+4 מחוברות ל-28 הסיביות שהתקבלו ליצירת כתובת היעד המלאה.
*   יחידת הבקרה מזהה את פקודת ה-Jump (opcode=2) ומפעילה אות בקרה חדש `Jump` השולט ב-MUX שלפני ה-PC.

## 6 Control Unit, Control Lines
### 6.1 Main Control Unit
*   **תפקיד**: לייצר את כל אותות הבקרה לרכיבי ה-Datapath (MUXים, ALU, כתיבה ל-RF/DM) על סמך ה-Opcode (ו-Funct בפקודות R-Type).
*   **מימוש**: לוגיקה קומבינטורית פשוטה (ניתן למימוש מטבלת אמת או ישירות באמצעות שערים לוגיים).
*   **ALU Control**: יחידה קטנה יותר המקבלת את קווי ה-ALUOp מהבקרה הראשית ואת שדה ה-Funct (בפקודות R-Type) ומייצרת את 4 קווי הבקרה הספציפיים הנכנסים ל-ALU עצמו וקובעים את הפעולה המדויקת.
#### 6.1.1 קווי איפשור (enable)
אלו הם קווי בקרה של ביט אחד הקובעים את מצב הפעולה של כל בלוק:

*   **RegWrite** – מאפשר כתיבה למקבץ האוגרים (עבור פקודות R-Type ו-lw).
*   **MemWrite** – מאפשר כתיבה לזיכרון הנתונים (עבור פקודת sw).
*   **MemRead** – מאפשר קריאה של תוכן תא נבחר מזיכרון הנתונים (עבור פקודת lw).

#### 6.1.2 קווי ברירה (Mux Control Lines)
אלו הם קווים בעלי עובי ביט אחד וקובעים את הכתובת או התוכן המועברים לבלוק הבא.
*   **RegDst** – בוחר את כתובת אוגר היעד אליו יש לכתוב תוכן.
    *   בפקודות מסוג R-Type מזוהה באוגר שכתובתו בסיביות `$[15:11]$` ($srd$).
    *   בפקודת lw מזוהה באוגר שכתובתו בסיביות `$[20:16]$` ($srt$).
*   **ALUSrc** – בוחר את התוכן שנכנס כיבוא השני ליחידת ה-ALU (האופרנד השני לביצוע הפעולה).
    *   בפקודות מסוג R-Type מזוהה התוכן בתוך האוגר $srt$ (שכתובתו בסיביות `$[20:16]$`).
    *   בפקודת lw מזוהה התוכן בתוך שדה ה-address לאחר הרחבת סימן ($[15:0]$ בסיביות) וחיבור $offset$.
*   **MemtoReg** – בוחר את התוכן שייכתב חזרה למקבץ האוגרים.
    *   בפקודות מסוג R-Type יש לכתוב לתוך $srd$ את מוצא ה-ALU.
    *   בפקודת lw יש לכתוב לכתוב למקבץ האוגרים (לתוך $srt$) את ערך המילה שנקראה מהזיכרון.

#### 6.1.3 סיכום מקומי של ערכי הסיביות של קווי הבקרה

| **Set (1)**                                                                                                          | **Reset (0)**                                       | **Line Width (bits)** | **Signal Name** |
|:-------------------------------------------------------------------------------------------------------------------- |:--------------------------------------------------- |:--------------------- |:--------------- |
| The content in Write Register ($srd$) is replaced with the new value (from ALU or Data Memory according to command). | No write is allowed                                 | 1                     | RegWrite        |
| The cell in Data Memory at Address opens for writing (replacing the current content with the new one).               | No write is allowed                                 | 1                     | MemWrite        |
| The cell in Data Memory at Address is output through Read Data data-line.                                            | No read is allowed                                  | 1                     | MemRead         |
| The register destination is $rd$ (Ins.$[15:11]$).                                                                    | The register destination is $rt$ (Ins.$[20:16]$).   | 1                     | RegDst          |
| Second ALU operand is the 32-bits signed extended Address value.                                                     | Second ALU operand is the content of $rt$ ($$rt$).  | 1                     | ALUSrc          |
| Content to write back to Register File is from Data Memory.                                                          | Content to write back to Register File is from ALU. | 1                     | MemtoReg        |
### 6.2 Secondary Control Unit (ALU Control)
> [!important]
> הבקרה המשנית ניזנת מהבקרה הראשית, כלומר מקבל את ערכי ה- OpCode שלה מהבקרה הראשית, ומבצעת עבורה את הבקרה על ה- ALU

למעשה, אם על ה-ALU לבצע אחת מתוך 3 אפשרויות לפעולה, נוכל לפשט את מימוש הבקרה בכך שנגדיר דרגת ביניים הנקראת בקרת משנית (ALU control) שבאויר הקודם. נגדיר שתי סיביות בקרה: `ALUOp1` ו-`ALUOp0`, הקובעות את אחת מ-3 האפשרויות באופן הבא:

| Instruction  | ALUOp | Instruction Operation | Funct Field | Desired ALU action | ALU control input |
| :----------- | :---- | :-------------------- | :---------- | :----------------- | :---------------- |
| lw           | 00    | Load word             | XXXXXX      | Add                | 0010              |
| sw           | 00    | Store word            | XXXXXX      | Add                | 0010              |
| Branch equal | 01    | Branch equal          | XXXXXX      | Subtract           | 0110              |
| R-Type       | 10    | Add                   | 100000      | Add                | 0010              |
| R-Type       | 10    | Subtract              | 100010      | Subtract           | 0110              |
| R-Type       | 10    | AND                   | 100100      | AND                | 0000              |
| R-Type       | 10    | OR                    | 100101      | OR                 | 0001              |
| R-Type       | 10    | Set on less than      | 101010      | Set on less than   | 0111              |

בהתאם לטבלה, נוכל לשלוט בארבעת קווי הבקרה של יחידת ה-ALU (ALU control lines) באמצעות שני הקווים: `ALUOp1`, `ALUOp0`.

*   אם ה-Opcode מתאים לפקודות lw או sw (ערכים: 35 ו-43 בהתאמה) ו-`ALUOp[1:0] = 00`, נבצע חיבור.
*   אם ה-Opcode מתאים ל-beq (ערך: 4) ו-`ALUOp[1:0] = 01`, נבצע חיסור.
*   אם ה-Opcode הוא 0 (פעולות מסוג R-Type) ו-`ALUOp[1:0] = 10`, נבצע את הפעולה לפי שדה ה-funct.

#### 6.2.1 למה בעצם צריך בקרת משנית?

הרעיון המרכזי העומד מאחורי סגנון המימוש של פיענוח מרובה שלבים (multiple level encoding), הוא להקטין את גודלה של יחידת הבקרה המרכזית. הדבר מתבטא בכך שיחידת הבקרה הראשית לא שולטת ישירות על כל סיביות הבקרה של כל הבלוקים, אלא מסתמכת על יחידת בקרת משנית עבור ה-ALU. היתרון בשיטה זו הוא פישוט תהליך הפיענוח בפקודות R-Type.

> [!info] הערה **בקרת משנית**
> הדבר המשלים בצורה ישירה על מהירות עדכון קווי הבקרה.

על כן, במעבדים מקובל לפצל את חלק הבקרה לרמות שונות (היררכיה) במטרה לשמור על יחידות קטנות שעובדות מהר ויעיל.

## 7 יתרונות וחסרונות

*   **יתרונות**:
    *   פשוט יחסית לתכנון ולהבנה.
*   **חסרונות**:
    *   **איטי**: אורך מחזור השעון נקבע לפי הפקודה האיטית ביותר (`lw`), מה שמבזבז זמן עבור פקודות מהירות יותר.
    *   **שימוש לא יעיל בחומרה**: כל רכיב פונקציונלי (כמו ALU, זיכרון) משמש רק פעם אחת במחזור שעון, למרות שהוא יכול להיות פנוי בחלק גדול מהזמן עבור פקודות מסוימות. (למשל, ה-Data Memory לא בשימוש בפקודות R-Type). דורש כפילות רכיבים (למשל, Adders ל-PC ול-Branch).
    * **חלוקת הזיכרון ל- 2:** הזיכרון מחולק ל- Instruction Memory ול- Data Memory, כאשר בפועל מדובר באותו רכיב זיכרון. ==זאת ע״מ לאפשר גישה לזיכרון גם לקריאה וגם לכתיבה, במחזור שעון אחד.==

## 8 הערכת ביצועים
*   **CPI = 1** לכל הפקודות.
*   **זמן מחזור השעון (CCT)** = זמן השלב הקריטי (הארוך ביותר) בפקודה האיטית ביותר (לרוב `lw`: I-Mem Read + Reg File Read + ALU (addr calc) + Data Mem Read + MUX + Reg File Write Setup).
*   **זמן CPU כולל**: $IC \times 1 \times CCT_{longest\_instruction}$.
*   ==הביצועים נמוכים יחסית בגלל ה-CCT הארוך.==

## 9 מרשם כולל של מעבד חד-מחזורי
![[SS 19052025 at 14.56.43.png]]