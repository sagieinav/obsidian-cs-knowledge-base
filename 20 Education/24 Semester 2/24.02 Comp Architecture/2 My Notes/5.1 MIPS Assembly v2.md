```table-of-contents
```

## 1. 📜 מבוא ל-MIPS Assembly

### 1.1 מה זה MIPS?
*   **MIPS**: Microprocessor without Interlocked Pipeline Stages.
*   ארכיטקטורת מעבד **RISC** (Reduced Instruction Set Computer) שפותחה בשנות ה-80.
*   משמשת כבסיס להבנת עקרונות שפת המכונה וארגון המחשב.

### 1.2 עקרונות תכנון RISC ב-MIPS
1.  **פשטות מעדיפה סדירות**: אורך פקודה קבוע (32 ביט), מעט פורמטים, שדות קבועים.
2.  **קטן יותר = מהיר יותר**: סט פקודות מצומצם, מספר רגיסטרים מוגבל (32 GPR), ארכיטקטורת Load/Store.
3.  **פשרות טובות בעיצוב**: שלושה פורמטי פקודות (R, I, J).
4.  **המקרה הנפוץ מהיר**: פקודות עם ערך מיידי (Immediate) קטן, פעולות עיקריות על רגיסטרים.

### 1.3 רמות ייצוג (חזרה)
*   שפה עילית $\rightarrow$ (Compiler) $\rightarrow$ אסמבלי $\rightarrow$ (Assembler) $\rightarrow$ שפת מכונה $\rightarrow$ (Hardware) $\rightarrow$ ביצוע.
*   אסמבלי: ייצוג טקסטואלי 1:1 (פחות או יותר) של שפת המכונה.

> [!NOTE] Abstraction Principle
> עקרון ההפשטה מאפשר לטפל בבעיות מורכבות ע"י הגדרת פונקציות בסיסיות ושימוש בהן, והגדרת ממשקים ברורים בין רמות שונות (כמו ה-ISA בין תוכנה לחומרה).

### 1.4 ארכיטקטורת מחשב ו-ISA
*   **ארכיטקטורת מחשב (Computer Architecture)** = ארכיטקטורת סט הפקודות (ISA) + ארגון המכונה (Machine Organization).
*   **ISA (Instruction Set Architecture)**: המודל האבסטרקטי המגדיר למתכנת/מהדר את יכולות המעבד: סט פקודות, רגיסטרים, סוגי נתונים, מודלי כתובות, פורמט פקודות, טיפול בפסיקות.

### 1.5 כלי עבודה: MARS
*   נשתמש בסימולטור **MARS** (MIPS Assembler and Runtime Simulator) לכתיבה, הרצה ודיבוג.

## 2. 🗄️ רגיסטרים ב-MIPS

### 2.1 מאפיינים
*   **32 רגיסטרים לשימוש כללי (GPR)**: ברוחב 32 סיביות, ממוספרים 0 עד 31.
*   **גישה מהירה**: מאוחסנים בתוך המעבד (ב-Register File).

### 2.2 רשימת הרגיסטרים המלאה

| מס' (Dec) | מס' (Hex) | שם מוסכם | תפקיד                                        | Callee-Saved? |
| :-------: | :-------: | :--------: | :------------------------------------------- | :-----------: |
| 0         | 0x0       | `$zero`    | קבוע 0                                       | -             |
| 1         | 0x1       | `$at`      | שמור לאסמבלר (Assembler Temporary)           | לא            |
| 2         | 0x2       | `$v0`      | ערך מוחזר / קוד Syscall                      | לא            |
| 3         | 0x3       | `$v1`      | ערך מוחזר                                    | לא            |
| 4         | 0x4       | `$a0`      | ארגומנט 1                                    | לא            |
| 5         | 0x5       | `$a1`      | ארגומנט 2                                    | לא            |
| 6         | 0x6       | `$a2`      | ארגומנט 3                                    | לא            |
| 7         | 0x7       | `$a3`      | ארגומנט 4                                    | לא            |
| 8         | 0x8       | `$t0`      | זמני 0 (Temporary)                           | לא            |
| 9         | 0x9       | `$t1`      | זמני 1                                       | לא            |
| 10        | 0xA       | `$t2`      | זמני 2                                       | לא            |
| 11        | 0xB       | `$t3`      | זמני 3                                       | לא            |
| 12        | 0xC       | `$t4`      | זמני 4                                       | לא            |
| 13        | 0xD       | `$t5`      | זמני 5                                       | לא            |
| 14        | 0xE       | `$t6`      | זמני 6                                       | לא            |
| 15        | 0xF       | `$t7`      | זמני 7                                       | לא            |
| 16        | 0x10      | `$s0`      | שמור 0 (Saved)                               | **כן**        |
| 17        | 0x11      | `$s1`      | שמור 1                                       | **כן**        |
| 18        | 0x12      | `$s2`      | שמור 2                                       | **כן**        |
| 19        | 0x13      | `$s3`      | שמור 3                                       | **כן**        |
| 20        | 0x14      | `$s4`      | שמור 4                                       | **כן**        |
| 21        | 0x15      | `$s5`      | שמור 5                                       | **כן**        |
| 22        | 0x16      | `$s6`      | שמור 6                                       | **כן**        |
| 23        | 0x17      | `$s7`      | שמור 7                                       | **כן**        |
| 24        | 0x18      | `$t8`      | זמני 8                                       | לא            |
| 25        | 0x19      | `$t9`      | זמני 9                                       | לא            |
| 26        | 0x1A      | `$k0`      | שמור לקרנל 0 (Kernel)                       | -             |
| 27        | 0x1B      | `$k1`      | שמור לקרנל 1                               | -             |
| 28        | 0x1C      | `$gp`      | Global Pointer                               | **כן**        |
| 29        | 0x1D      | `$sp`      | Stack Pointer                                | **כן**        |
| 30        | 0x1E      | `$fp`      | Frame Pointer                                | **כן**        |
| 31        | 0x1F      | `$ra`      | Return Address                               | **כן**        |

> [!IMPORTANT] Register Conventions Usage
> יש להקפיד על מוסכמות השימוש, בעיקר ההבחנה בין **Caller-saved** (כמו `$t`) ל-**Callee-saved** (כמו `$s`), לשמירה על תקינות הקוד בקריאות לפונקציות. הפונקציה הקוראת אחראית לשמור `$t` אם היא צריכה אותם אחרי הקריאה, והפונקציה הנקראת אחראית לשמור `$s` אם היא משתמשת בהם.

### 2.3 רגיסטרים מיוחדים נוספים

###### PC (Program Counter)
*   רגיסטר פנימי, מחזיק את **כתובת** הפקודה הבאה לביצוע.

###### HI / LO
*   רגיסטרים פנימיים לתוצאות **כפל** (64 ביט) ו**חילוק** (מנה ושארית).
*   גישה באמצעות `mfhi`/`mflo`.

## 3. 📝 פורמטי פקודות MIPS

כל הפקודות באורך 32 סיביות, 3 פורמטים עיקריים:

### 3.1 R-Type (Register)
*   **מבנה**: `op(0) | rs(5) | rt(5) | rd(5) | shamt(5) | funct(6)`
*   **שימוש**: פעולות רגיסטר-רגיסטר.
*   **שדות**: `op`(0), `rs`(מקור1), `rt`(מקור2), `rd`(יעד), `shamt`(הזזה), `funct`(פונקציה).

### 3.2 I-Type (Immediate)
*   **מבנה**: `op(6) | rs(5) | rt(5) | immediate(16)`
*   **שימוש**: פעולות עם מיידי, Load/Store, Branches.
*   **שדות**: `op`, `rs`(מקור/בסיס), `rt`(מקור/יעד), `immediate`(ערך מיידי/Offset).

### 3.3 J-Type (Jump)
*   **מבנה**: `op(6) | target address(26)`
*   **שימוש**: קפיצות לא מותנות.
*   **שדות**: `op`, `target address`.

> [!NOTE] Opcode Field
> שדה ה-`opcode` (`[31-26]`) קובע את הפורמט והפעולה הכללית. בפקודות R-Type, ה-opcode הוא 0 ושדה ה-`funct` מבדיל בין הפעולות.

## 4. ⚙️ פקודות MIPS עיקריות

### 4.1 פקודות R-Type
(פעולות רגיסטר-רגיסטר, `op=0`)

| פקודה | Funct (Hex) | Funct (Dec) | תחביר לדוגמה     | פעולה                          |
| :------ | :---------: | :---------: | :--------------- | :------------------------------ |
| `add`   | 0x20        | 32          | `add $1,$2,$3`   | `$1 = $2 + $3` (עם גלישה)       |
| `sub`   | 0x22        | 34          | `sub $1,$2,$3`   | `$1 = $2 - $3` (עם גלישה)       |
| `addu`  | 0x21        | 33          | `addu $1,$2,$3`  | `$1 = $2 + $3` (בלי גלישה)      |
| `subu`  | 0x23        | 35          | `subu $1,$2,$3`  | `$1 = $2 - $3` (בלי גלישה)      |
| `and`   | 0x24        | 36          | `and $1,$2,$3`   | `$1 = $2 & $3`                  |
| `or`    | 0x25        | 37          | `or $1,$2,$3`    | `$1 = $2 | $3`                  |
| `xor`   | 0x26        | 38          | `xor $1,$2,$3`   | `$1 = $2 ^ $3`                  |
| `nor`   | 0x27        | 39          | `nor $1,$2,$3`   | `$1 = ~($2 | $3)$`              |
| `slt`   | 0x2a        | 42          | `slt $1,$2,$3`   | `$1 = ($2 < $3) ? 1 : 0` (signed) |
| `sltu`  | 0x2b        | 43          | `sltu $1,$2,$3`  | `$1 = ($2 < $3) ? 1 : 0` (unsigned)|
| `sll`   | 0x00        | 0           | `sll $1,$2,10`   | `$1 = $2 << 10` (Shift Left Logical) |
| `srl`   | 0x02        | 2           | `srl $1,$2,10`   | `$1 = $2 >> 10` (Shift Right Logical)|
| `sra`   | 0x03        | 3           | `sra $1,$2,10`   | `$1 = $2 >> 10` (Shift Right Arithmetic)|
| `sllv`  | 0x04        | 4           | `sllv $1,$2,$3`  | `$1 = $2 << $3` (Shift Left Variable) |
| `srlv`  | 0x06        | 6           | `srlv $1,$2,$3`  | `$1 = $2 >> $3` (Shift Right Logical Var) |
| `srav`  | 0x07        | 7           | `srav $1,$2,$3`  | `$1 = $2 >> $3` (Shift Right Arithmetic Var)|
| `jr`    | 0x08        | 8           | `jr $ra`         | `PC = $ra` (Jump Register)     |
| `mult`  | 0x18        | 24          | `mult $2,$3`     | `(Hi,Lo) = $2 * $3` (Signed 64b)|
| `multu` | 0x19        | 25          | `multu $2,$3`    | `(Hi,Lo) = $2 * $3` (Unsigned 64b)|
| `div`   | 0x1a        | 26          | `div $2,$3`      | `Lo=$2/$3, Hi=$2%$3` (Signed)   |
| `divu`  | 0x1b        | 27          | `divu $2,$3`     | `Lo=$2/$3, Hi=$2%$3` (Unsigned) |
| `mfhi`  | 0x10        | 16          | `mfhi $1`        | `$1 = Hi`                       |
| `mflo`  | 0x12        | 18          | `mflo $1`        | `$1 = Lo`                       |

### 4.2 פקודות I-Type 🔢

#### 4.2.1 פעולות אריתמטיות/לוגיות עם מיידי
*   `rt = rs op Sign/ZeroExtended(immediate)`

| פקודה | Opcode (Hex) | תחביר לדוגמה     | פעולה                   | הרחבה |
| :------ | :----------: | :--------------- | :----------------------- | :----: |
| `addi`  | 0x8          | `addi $1,$2,-100`| `$1 = $2 + (-100)`       | Sign   |
| `addiu` | 0x9          | `addiu $1,$2,100`| `$1 = $2 + 100`          | Sign   |
| `andi`  | 0xC          | `andi $1,$2,0xFF`| `$1 = $2 & 0xFF`         | Zero   |
| `ori`   | 0xD          | `ori $1,$2,0xF0` | `$1 = $2 | 0xF0`         | Zero   |
| `xori`  | 0xE          | `xori $1,$2,0xAA`| `$1 = $2 ^ 0xAA`         | Zero   |
| `slti`  | 0xA          | `slti $1,$2,6`   | `$1 = ($2 < 6) ? 1 : 0`  | Sign   |
| `sltiu` | 0xB          | `sltiu $1,$2,6`  | `$1 = ($2 < 6) ? 1 : 0`  | Sign   |
| `lui`   | 0xF          | `lui $1, 0xABCD` | `$1 = 0xABCD0000`        | Special|

#### 4.2.2 גישה לזיכרון (Load/Store)
*   `Effective Address = rs + SignExtended(immediate)`
*   **Alignment**: כתובת Word חייבת להתחלק ב-4.

| פקודה | Opcode (Hex) | תחביר לדוגמה      | פעולה                      |
| :------ | :----------: | :---------------- | :-------------------------- |
| `lw`    | 0x23         | `lw $t0, 8($sp)`  | `$t0 = Memory[$sp + 8]`     |
| `sw`    | 0x2B         | `sw $a0, 12($sp)` | `Memory[$sp + 12] = $a0`    |
| `lb`    | 0x20         | `lb $t0, ($s0)`   | `$t0 = SignExtend(Mem[$s0])` |
| `lbu`   | 0x24         | `lbu $t0, ($s0)`  | `$t0 = ZeroExtend(Mem[$s0])`|
| `sb`    | 0x28         | `sb $t1, ($s0)`   | `Memory[$s0] = $t1[7:0]`    |
| `lh`    | 0x21         | `lh $t0, 2($s0)`  | `$t0 = SignExtend(Mem[$s0+2])`|
| `lhu`   | 0x25         | `lhu $t0, 2($s0)`  | `$t0 = ZeroExtend(Mem[$s0+2])`|
| `sh`    | 0x29         | `sh $t1, 4($s0)`  | `Memory[$s0+4] = $t1[15:0]` |

> [!WARNING] Alignment Error
> גישה לזיכרון בכתובת לא מיושרת תגרום ל-Exception.

#### 4.2.3 בקרת זרימה (Branches)
*   קפיצות **מותנות** ו**יחסיות** ל-`PC+4`.
*   **חישוב יעד**: `Target = PC + 4 + (SignExtend(immediate) * 4)`

| פקודה | Opcode (Hex) | תחביר לדוגמה        | תנאי לקפיצה             |
| :------ | :----------: | :------------------ | :---------------------- |
| `beq`   | 0x4          | `beq $s0, $s1, L`   | `if ($s0 == $s1)`         |
| `bne`   | 0x5          | `bne $t0, $zero, L` | `if ($t0 != $zero)`       |
| `bgez`  | 0x1 (rt=1)   | `bgez $s0, L`       | `if ($s0 >= 0)`         |
| `bgtz`  | 0x7 (rt=0)   | `bgtz $s0, L`       | `if ($s0 > 0)`          |
| `blez`  | 0x6 (rt=0)   | `blez $s0, L`       | `if ($s0 <= 0)`         |
| `bltz`  | 0x1 (rt=0)   | `bltz $s0, L`       | `if ($s0 < 0)`          |

> [!NOTE] Branch on Zero Instructions
> הפקודות `bgez`, `bgtz`, `blez`, `bltz` משתמשות בשדה `rt` שבפורמט I כדי להבדיל ביניהן, בעוד הן בודקות רק את רגיסטר `rs`.

### 4.3 פקודות J-Type ↷
(קפיצות לא מותנות)

*   **חישוב יעד**: `Target = (PC+4)[31:28] | (target_address << 2)`

| פקודה | Opcode (Hex) | תחביר לדוגמה | פעולה                               |
| :------ | :----------: | :------------ | :--------------------------------- |
| `j`     | 0x2          | `j MainLoop`  | `PC = Target Address` (Jump)       |
| `jal`   | 0x3          | `jal MyFunc`  | `$ra = PC + 4; PC = Target Address` (Jump and Link) |

### 4.4 פסאודו-פקודות (Pseudo-Instructions) ✨
*   פקודות נוחות למתכנת שהאסמבלר מתרגם לפקודות מכונה אמיתיות.

| פסאודו-פקודה | פקודת מכונה שקולה (דוגמה)                      | משמעות                     |
| :------------- | :---------------------------------------------- | :------------------------- |
| `move $t1,$t2` | `addu $t1,$t2,$zero`                          | `$t1 = $t2`                  |
| `li $t0, imm`  | (תלוי ב-imm) `ori`/`lui`+`ori`                | Load Immediate           |
| `la $t0, label`| `lui $at, upper(addr)`+`ori $t0, $at, lower(addr)`| Load Address               |
| `blt $s0,$s1,L`| `slt $at,$s0,$s1` + `bne $at,$zero,L`          | Branch if Less Than        |
| `bgt $s0,$s1,L`| `slt $at,$s1,$s0` + `bne $at,$zero,L`          | Branch if Greater Than     |
| `ble $s0,$s1,L`| `slt $at,$s1,$s0` + `beq $at,$zero,L`          | Branch if Less or Equal  |
| `bge $s0,$s1,L`| `slt $at,$s0,$s1` + `beq $at,$zero,L`          | Branch if Greater or Equal|
| `not $t0, $t1` | `nor $t0, $t1, $zero`                         | `$t0 = ~ $t1`                |

## 5. ⌨️ תכנות בסיסי באסמבלי (מפגש 4)

### 5.1 מבנה תוכנית אסמבלי ב-MARS
*   **הערות**: `# ...`
*   **הנחיות אסמבלר (Directives)**: `.data`, `.text`, `.globl`, `.word`, `.half`, `.byte`, `.asciiz`, `.space`, `.align`.
*   **הגדרת נתונים** (`.data`).
*   **פקודות** (`.text`).
*   **סיום תוכנית**: `syscall` עם קוד 10.

### 5.2 קריאות מערכת (System Calls) ב-MARS 📞
*   קוד שירות ב-`$v0`, ארגומנטים ב-`$a0+`, `syscall`, תוצאה ב-`$v0`.
*   **שירותים נפוצים**: 1(print_int), 4(print_string), 5(read_int), 8(read_string), 10(exit).

### 5.3 מבנה הזיכרון 🗺️
*   **מקטעים**: Reserved, Text, Static Data, Dynamic Data (Heap), Stack.
*   **יישור (Alignment)**: חובה.
*   **Endianness**: MARS הוא Little Endian.

### 5.4 ASCII
*   קוד סטנדרטי לייצוג תווים. שימושי ב-`lb`/`sb` ומחרוזות.