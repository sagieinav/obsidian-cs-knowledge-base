```table-of-contents
```
## 1. 🏭 עקרון ההרנצה (Pipelining)

> [!WARNING] Single-Cycle & Multi-Cycle Limitations
> *   **Single-Cycle**: מחזור שעון ארוך מאוד, נקבע ע"י הפקודה האיטית ביותר. שימוש לא יעיל בחומרה.
> *   **Multi-Cycle**: מחזור שעון קצר יותר, אך עדיין בכל מחזור שעון רק חלק מהחומרה פעיל. CPI > 1.

###### הרעיון המרכזי: חפיפה (Overlap)
**Pipeline**: טכניקה לשיפור **Throughput** (הספק - פקודות ליחידת זמן) של המעבד ע"י ביצוע השלבים של פקודות שונות **במקביל**, במקום לחכות שפקודה אחת תסיים את כל שלביה.

###### חלוקה לשלבים
מחלקים את ביצוע הפקודה למספר שלבים (ב-MIPS: 5 שלבים - IF, ID, EX, MEM, WB).

###### זרימה
באופן אידיאלי, בכל מחזור שעון, פקודה חדשה נכנסת לשלב הראשון (IF), והפקודות הקודמות מתקדמות לשלב הבא.

###### אנלוגיית המכבסה
ניתן להתחיל כביסה חדשה (IF) ברגע שהקודמת עברה למייבש (ID $\rightarrow$ EX), מבלי לחכות לסיום הקיפול (WB).

## 2. ⚙️ שלבים וביצועים ב-MIPS Pipeline

### 2.1 שלבי ה-Pipeline (5 שלבים)
1.  **IF (Instruction Fetch)**: הבאת פקודה מהזיכרון (IM), עדכון PC ל-PC+4.
2.  **ID (Instruction Decode / Register Read)**: פיענוח פקודה, קריאת רגיסטרי מקור (rs, rt) מ-Register File.
3.  **EX (Execute / Address Calculation)**: ביצוע פעולת ALU, חישוב כתובת זיכרון, חישוב תנאי וכתובת Branch.
4.  **MEM (Memory Access)**: גישה לזיכרון הנתונים (DM) לקריאה (`lw`) או כתיבה (`sw`).
5.  **WB (Write Back)**: כתיבת התוצאה (מה-ALU או מה-DM) חזרה ל-Register File.

### 2.2 יתרונות וביצועים

##### Throughput גבוה
באופן אידיאלי, פקודה חדשה מסיימת בכל מחזור שעון $\implies$ **CPI אידיאלי = 1**.

##### Latency (זמן לפקודה בודדת)
שווה למספר השלבים כפול זמן מחזור השעון (לא משתפר לעומת Multi-cycle).

##### זמן מחזור השעון (CCT)
נקבע ע"י השלב **האיטי ביותר** מבין שלבי ה-Pipeline. קצר משמעותית מה-CCT של Single-Cycle.

##### האצה (Speedup)
*   באופן אידיאלי: $Speedup \approx \text{Number of Stages}$.
*   בפועל: ההאצה נמוכה יותר בגלל Hazards, Overhead ושלבים לא מאוזנים.

> [!IMPORTANT] Throughput vs Latency
> Pipelining משפר דרמטית את ה-**Throughput**, אך **לא** את ה-**Latency**.

## 3. 🛠️ מימוש Pipeline ב-MIPS

### 3.1 התאמת ארכיטקטורת MIPS
MIPS מתאימה יחסית ל-Pipeline בזכות:
*   אורך פקודה קבוע (32 ביט).
*   מעט פורמטים (3) וסדירות.
*   ארכיטקטורת Load/Store.
*   כתיבת תוצאה יחידה בסוף (לרוב ב-WB).

### 3.2 נתיב הנתונים (Datapath) ב-Pipeline

##### רגיסטרי Pipeline
נדרשים רגיסטרים בין כל זוג שלבים (IF/ID, ID/EX, EX/MEM, MEM/WB) להעברת מידע (נתונים, כתובות, אותות בקרה) לשלב הבא. הם נכתבים בסוף כל מחזור שעон.

##### זרימת נתונים ובקרה
הנתונים ואותות הבקרה "זורמים" דרך רגיסטרי ה-Pipeline משלב לשלב. כל שלב קומבינטורי פועל על המידע מהרגיסטר שלפניו ומעביר את התוצאות לרגיסטר שאחריו.

{לשים פה דיאגרמה}
*(דיאגרמה סכמטית פשוטה של ה-Datapath ב-Pipeline)*

## 4. ⚠️ סיכונים ב-Pipeline (Hazards) - מבוא

###### הגדרה
מצבים המונעים מהפקודה הבאה להתחיל/להשלים שלב כמתוכנן.

###### סוגים עיקריים
*   **Structural Hazards (סיכונים מבניים)**: שימוש מתנגש באותו רכיב חומרה. (נפתר לרוב ב-MIPS ע"י הפרדת זיכרונות/caches).
*   **Data Hazards (סיכוני נתונים)**: תלות בנתון שטרם חושב/נכתב.
*   **Control Hazards (סיכוני בקרה)**: אי-ודאות לגבי הפקודה הבאה עקב Branches/Jumps.

###### פתרון כללי
**Stalling / Bubbles** (המתנה/הכנסת בועות), אך מחפשים פתרונות יעילים יותר.

> [!IMPORTANT] Hazards Impact Performance
> סיכונים (Hazards) הם הגורם העיקרי לכך שה-CPI בפועל ב-Pipeline גבוה מ-1, וההאצה נמוכה מהאידיאל. הטיפול בהם הוא קריטי לביצועי המעבד.