```table-of-contents
```
## 1 🧱 לוגיקה צירופית (Combinational Logic)

### 1.1 הגדרה ומאפיינים
*   מעגלים לוגיים שבהם הפלט תלוי **אך ורק** בערכי הקלט הנוכחיים.
*   אין להם "זיכרון" או מצב פנימי הנשמר בין מחזורי שעון.
*   שינוי בקלט גורם (לאחר השהיה קצרה) לשינוי בפלט.
*   בניגוד ללוגיקה סדרתית (Sequential Logic), אינם תלויי שעון באופן ישיר לצורך קביעת הפלט.

### 1.2 רכיבים קומבינטוריים עיקריים

### 1.3 מפענח (Decoder)
*   רכיב עם $n$ קווי קלט ו-$2^n$ קווי פלט.
*   עבור כל צירוף קלט אפשרי, **רק קו פלט אחד** יהיה פעיל (לרוב 1, והשאר 0).
*   ניתן להוסיף קו בקרה **Enable (E)**. אם E=0, כל היציאות 0. אם E=1, המפענח עובד רגיל. מאפשר שרשור מפענחים.

### 1.4 מקודד (Encoder)
*   פעולה הפוכה למפענח: $2^n$ קווי קלט ו-$n$ קווי פלט.
*   בהנחה שרק קו קלט אחד פעיל, הפלט מייצג את **האינדקס הבינארי** של קו הקלט הפעיל.
*   **מקודד עדיפות (Priority Encoder)**: פותר את בעיית הקלטים המרובים ע"י הגדרת עדיפות. הפלט מייצג את האינדקס של הקלט הפעיל בעל העדיפות הגבוהה ביותר. כולל יציאת **Valid (V)**.

### 1.5 מרבב (Multiplexer - MUX)
*   רכיב חשוב ביותר ("בורר").
*   $2^n$ כניסות נתונים, $n$ קווי בקרה (Select Lines), ויציאת נתונים **אחת**.
*   מעביר את **אחת** מכניסות הנתונים אל היציאה, בהתאם לערך הבינארי בקווי הבקרה.
*   ניתן להרחיב לטיפול ב-**Bus** (אפיק נתונים רחב).

## 2 ➕ מימוש מחברים (Adders)

### 2.1 מחבר-למחצה (Half Adder - HA)
*   מחבר שתי סיביות בודדות ($a, b$).
*   מוציא **סכום (Sum - S)** ו-**נֶשֶׂא (Carry - C)**.
*   $S = a \oplus b$
*   $C = a \cdot b$

### 2.2 מחבר מלא (Full Adder - FA)
*   מחבר שלוש סיביות: $a, b, C_{in}$.
*   מוציא **סכום (Sum - S)** ו-**נֶשֶׂא החוצה ($C_{out}$)**.
*   $S = a \oplus b \oplus C_{in}$
*   $C_{out} = (a \cdot b) + (a \cdot C_{in}) + (b \cdot C_{in})$
*   ניתן למימוש מ-2 HA + OR.

### 2.3 מחבר אדווה (Ripple Carry Adder - RCA)
*   מחבר מספרים ברוחב $N$ סיביות ע"י שרשור $N$ יחידות FA.
*   $C_{out}$ של דרגה $i$ הוא $C_{in}$ של דרגה $i+1$.
*   **חיסרון**: איטי עבור $N$ גדול עקב התפשטות הנשא.

## 3 ➖ מימוש מחסר (Subtractor)

*   מבוסס על חיבור המשלים ל-2: $A - B = A + (\sim B + 1)$.
*   **מימוש**: היפוך סיביות $B$ + חיבור עם $A$ + הכנסת $C_{in}=1$ ל-FA הראשון.
*   **מחבר/מחסר משולב**: שימוש בקו בקרה `Sub` כדי לבחור אם להפוך את $B$ ולהכניס $C_{in}=1$ (חיסור) או לא (חיבור).

## 4 🛠️ בניית יחידה אריתמטית-לוגית (ALU)

### 4.1 תפקיד ומבנה
*   **תפקיד**: הרכיב המרכזי המבצע פעולות אריתמטיות ולוגיות.
*   בנוי כלוגיקה **קומבינטורית**.
*   **מבנה (עבור $N$ סיביות)**:
    1.  $N$ יחידות של "1-bit ALU" משוכפלות.
    2.  כל 1-bit ALU מכיל לוגיקה לביצוע AND, OR, חיבור (FA), ולפעמים NOR, SLT.
    3.  **MUX פנימי** בכל 1-bit ALU בוחר את תוצאת הפעולה לפי קווי הבקרה (`ALU Control`).
    4.  קווי בקרה נוספים (`Ainvert`, `Bnegate`) יכולים להפוך את הקלטים לפני הפעולה.
    5.  חיבור $C_{out}$ ל-$C_{in}$ בין היחידות עבור פעולות אריתמטיות (כמו ב-RCA).
    6.  **טיפול מיוחד ב-SLT**: תוצאת ההשוואה (מה-MSB) מוזנת ל-LSB ומשם לשאר הסיביות.
    7.  **יציאות נוספות (דגלים)**: Zero, CarryOut, Overflow, Sign (Negative).

> [!NOTE] ALU Control Lines
> ה-ALU מקבל מספר קווי בקרה (ב-MIPS לרוב 4 סיביות) הקובעים איזו פעולה תתבצע. למשל:
> *   `0000` -> AND
> *   `0001` -> OR
> *   `0010` -> ADD
> *   `0110` -> SUBTRACT (ממומש כ-ADD עם Bnegate=1, Cin=1)
> *   `0111` -> SLT
> *   `1100` -> NOR (ממומש כ-OR עם Ainvert=1, Bnegate=1, ואז היפוך התוצאה או שימוש ב-NOR Gate ישיר בתוך ה-1-bit ALU)
![[SS 06052025 at 17.07.54.png]]



### 4.2 דגלי סטטוס (ALU Flags)

*   **Z (Zero)**: 1 אם תוצאת ה-ALU היא 0 (כל הסיביות 0).
*   **C (CarryOut)**: ה-Carry Out מהסיבית המשמעותית ביותר (MSB). מצביע על גלישה בחיבור/חיסור Unsigned.
*   **O (Overflow)**: 1 אם התרחשה גלישה אריתמטית בשיטת המשלים ל-2. $O = C_{in\_to\_MSB} \oplus C_{out\_of\_MSB}$.
*   **S (Sign/Negative)**: ערך סיבית התוצאה המשמעותית ביותר (MSB). 1 אם התוצאה שלילית (במשלים ל-2).

> [!IMPORTANT] ALU Flags Usage
> הדגלים הללו, במיוחד Zero, משמשים את יחידת הבקרה למימוש פקודות מותנות כמו Branches (`beq`, `bne`).


