> [!toc] *Table of Contents*
> ```toc
## 1 Java `Comparable` Interface

> [!note] Definition **`Comparable`**
> An interface in Java that allows objects of a specific type to compare themselves to other objects of the same type, thereby defining a natural ordering for these objects. The interface includes one method:
> ```java
> public int compareTo(T other);
> ```
> The method returns:
> - A negative value: if the current object is less than $other$.
> - 0: if the current object is equal to $other$.
> - A positive value: if the current object is greater than $other$.
### 1.1 Sorting Arrays of Primitive Types and Objects

- The `Arrays.sort()` method works correctly for arrays of primitive types (like `int`) because the comparison operator (`<, >, ==)` is defined for them.


```java
public static void main(String[] args) {
  int[] arr = {32,5,2,8,4,6,9,7};
  System.out.println("Before sorting: " + Arrays.toString(arr));
  Arrays.sort(arr);
  System.out.println("After sorting: " + Arrays.toString(arr));
}
```
console:
Before sorting: [32, 5, 2, 8, 4, 6, 9, 7]
After sorting: [2, 4, 5, 6, 7, 8, 9, 32]

- When sorting an array of custom objects, `Arrays.sort()` requires the objects to implement the `Comparable` interface, otherwise a `ClassCastException` will be thrown.

```java
public class Person {
  private String name;
  private int age;
  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }
  @Override
  public String toString() {
    return "{" + name + ", " + age + "}";
  }
}
```
```java
Person[] arr = {new Person("Yosi", 27),new Person("Yael", 22),new Person("Mor", 25)};
System.out.println("Before sorting: " + Arrays.toString(arr));
Arrays.sort(arr); // Throws ClassCastException
```
console:
Before sorting: [{Yosi, 27}, {Yael, 22}, {Mor, 25}]
Exception in thread "main" java.lang.ClassCastException: class Person cannot be cast to class java.lang.Comparable…

### 1.2 Implementing `Comparable` for Objects

To enable sorting an array of `Person` objects by age, you must implement the `Comparable<Person>` interface in the `Person` class and provide an implementation for the `compareTo` method.

```java
public class Person implements Comparable<Person> {
  private String name;
  private int age;
  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }
  @Override
  public String toString() {
    return "{" + name + ", " + age + "}";
  }
  @Override
  public int compareTo(Person other) {
    return this.age - other.age; // Sort by age
  }
}
```
```java
Person[] arr = {new Person("Yosi", 27),new Person("Yael", 22),new Person("Mor", 25)};
System.out.println("Before sorting: " + Arrays.toString(arr));
Arrays.sort(arr);
System.out.println("After sorting: " + Arrays.toString(arr));
```
console:
Before sorting: [{Yosi, 27}, {Yael, 22}, {Mor, 25}]
After sorting: [{Yael, 22}, {Mor, 25}, {Yosi, 27}]

### 1.3 Exercise 1: Comparing Objects of Different Types Implementing `Comparable` via Inheritance

> [!example] Exercise **`compareTo` with Inheritance**
> Given code that includes an abstract base class `Person` implementing `Comparable<Person>` and subclasses `Student` and `Lecturer` inheriting from it. The `Student` class overrides `compareTo` in an unsafe way (casting to `Student`). What will happen when the following code is executed?

```java
> abstract class Person implements Comparable<Person> {
>   protected final String name;
>   protected Person(String name) {
>     this.name = name;
>   }
>   @Override
>   public int compareTo(Person other) {
>     return name.compareTo(other.name); // Default comparison by name
>   }
> }
> class Student extends Person {
>   public Student(String name) {
>     super(name);
>   }
>   @Override
>   public int compareTo(Person other) {
>     Student s = (Student) other; // Unsafe cast
>     return name.compareTo(s.name);
>   }
> }
> class Lecturer extends Person {
>   public Lecturer(String name) {
>     super(name);
>   }
> }
> public class Main {
>   public static void main(String[] args) {
>     Person p1 = new Student("Noa");
>     Person p2 = new Lecturer("Adam");
>     System.out.println(p1.compareTo(p2));
>   }
> }
> ```

> [!NOTE] Explanation **Solution to Exercise 1**
> When the code is executed, and `p1.compareTo(p2)` is called, the `compareTo` method in the `Student` class is invoked (due to polymorphism). Inside this method, an attempt is made to cast the `other` object (which is of type `Lecturer`) to an object of type `Student`. This operation will fail and throw a `ClassCastException` at runtime.

## 2 📊 2. Relationship between `Comparable` and `equals`

- The `Comparable` interface defines an ordering, while the `equals` method defines equality.
- Different Java Collections handle equality or ordering in different ways. For example:
    - `TreeSet` uses the `compareTo` method to determine if two objects are equal (if `compareTo` returns 0, they are considered equal within the set), and therefore adds only one object if `compareTo` returns 0 for them.
    - `HashMap` uses the `equals` and `hashCode` methods (if defined) to determine if two keys are equal. If `equals` returns `true`, the new key will replace the existing value for the old key.

> [!example] Exercise **`Comparable` and `equals` in Collections**
> Given code that defines a `Person` class implementing both `Comparable` (by age) and `equals` (by name and age). The code inserts two `Person` objects with the same age but different names into a `TreeSet` and a `HashMap`. What will be the output?
> 
```java
> class Person implements Comparable<Person> {
>   protected final String name;
>   protected final int age;
>   protected Person(String name, int age) {
>     this.name = name;
>     this.age = age;
>   }
>   @Override
>   public int compareTo(Person other) {
>     return Integer.compare(age, other.age); // Compare by age
>   }
>   @Override
>   public boolean equals(Object obj) {
>     if (this == obj){
>       return true;
>     }
>     if (obj instanceof Person person){
>       return name.equals(person.name) && age == person.age; // Compare by name and age
>     }
>     return false;
>   }
>   @Override
>   public String toString() {
>     return "(" + name + ", " + age + ")";
>   }
> }
> public class Main {
>   public static void main(String[] args) {
>     Person p1 = new Person("Alice", 30);
>     Person p2 = new Person("Bob", 30);
>     System.out.println("Comparing by compare: " + p1.compareTo(p2)); // compareTo returns 0 (same age)
>     System.out.println("Comparing by equals: " + p1.equals(p2)); // equals returns false (different names)
>     TreeSet<Person> treeSet = new TreeSet<>();
>     treeSet.add(p1);
>     treeSet.add(p2); // p2 considered equal to p1 by compareTo(0), not added as a distinct element
>     System.out.println(treeSet);
>     HashMap<Person, Integer> hashMap = new HashMap<>();
>     hashMap.put(p1, 10); // p1 mapped to 10
>     hashMap.put(p2, 14); // p2 is not equal to p1 by equals, so added as a new key-value pair
>     System.out.println(hashMap);
>   }
> }
> ```
console:
Comparing by compare: 0
Comparing by equals: false
[(Alice, 30)]
{(Bob, 30)=14, (Alice, 30)=10}

> [!IMPORTANT] Important Point **Consistency between `compareTo` and `equals`**
> Generally, it is recommended that the `compareTo` and `equals` methods are consistent, meaning if `compareTo` returns 0, then `equals` should return `true`, and vice versa. Inconsistency can lead to unexpected behavior in order-based collections like `TreeSet` and `TreeMap`.

### 2.1 Exercise 2: Comparing Different Objects using `compareTo` with Casting and `instanceof`

> [!example] Exercise **Complex `compareTo` with Inheritance**
> Given code that includes an `Employee` class implementing `Comparable<Employee>` (comparison by name) and a `Manager` class inheriting from it that overrides `compareTo` to compare first by `level` if both objects are Managers, and otherwise fall back to comparing by name (using `super.compareTo`). What will happen when the following code is executed?

```java
> class Employee implements Comparable<Employee> {
>   protected final String name;
>   public Employee(String name) {
>     this.name = name;
>   }
>   @Override
>   public int compareTo(Employee other) {
>     return name.compareTo(other.name); // Compare by name
>   }
>   @Override
>   public String toString() {
>     return name;
>   }
> }
> class Manager extends Employee {
>   private final int level;
>   public Manager(String name, int level) {
>     super(name);
>     this.level = level;
>   }
>   @Override
>   public int compareTo(Employee other) {
>     if (other instanceof Manager m) { // Check if 'other' is a Manager
>       int res = Integer.compare(this.level, m.level); // Compare by level if both are Managers
>       if (res != 0) return res;
>     }
>     return super.compareTo(other); // Otherwise, compare by name (using Employee's compareTo)
>   }
> }
> public class Main {
>   public static void main(String[] args) {
>     Employee e1 = new Manager("Kobi", 3);
>     Employee e2 = new Employee("Dor");
>     Employee e3 = new Manager("Keren", 2);
>     Employee e4 = new Manager("Yahara", 3);
>     Employee e5 = new Employee("Tom");
>     System.out.println(e1 + " vs " + e2 + ": " + e1.compareTo(e2)); // Manager vs Employee -> compare by name
>     System.out.println(e2 + " vs " + e3 + ": " + e2.compareTo(e3)); // Employee vs Manager -> compare by name
>     System.out.println(e1 + " vs " + e4 + ": " + e1.compareTo(e4)); // Manager vs Manager -> compare by level (same), then by name
>     System.out.println(e3 + " vs " + e4 + ": " + e3.compareTo(e4)); // Manager vs Manager -> compare by level
>     System.out.println(e2 + " vs " + e5 + ": " + e2.compareTo(e5)); // Employee vs Employee -> compare by name
>   }
> }
> ```

> [!NOTE] Explanation **Solution to Exercise 2**
> The output will be as follows, according to the comparison logic defined in each class's `compareTo` method:
> Kobi vs Dor: Kobi.compareTo(Dor) (Employee logic) -> Kobi > Dor -> positive value
> Dor vs Keren: Dor.compareTo(Keren) (Employee logic) -> Dor < Keren -> negative value
> Kobi vs Yahara: Kobi.compareTo(Yahara) (Manager logic, same level) -> Kobi < Yahara -> negative value
> Keren vs Yahara: Keren.compareTo(Yahara) (Manager logic) -> Keren (level 2) < Yahara (level 3) -> negative value
> Dor vs Tom: Dor.compareTo(Tom) (Employee logic) -> Dor < Tom -> negative value
>
> The exact numerical values of the negative or positive results depend on the specific implementation of `String.compareTo` and `Integer.compare`.
>
> console:
> Kobi vs Dor: (positive value)
> Dor vs Keren: (negative value)
> Kobi vs Yahara: (negative value)
> Keren vs Yahara: (negative value)
> Dor vs Tom: (negative value)

## 3 📈 3. Java `Comparator` Interface

> [!note] Definition **`Comparator`**
> An interface in Java that allows defining an external object (Comparator) that can compare two objects of a specific type. Unlike `Comparable`, which defines a natural ordering within the class itself, `Comparator` provides a way to define different sorting orders for the same class, or to sort classes that do not implement `Comparable`. The interface includes one method:
> ```java
> public int compare(T obj1, T obj2);
> ```
> The method returns:
> - A negative value: if $obj1$ is less than $obj2$.
> - 0: if $obj1$ is equal to $obj2$.
> - A positive value: if $obj1$ is greater than $obj2$.

### 3.1 Using `Comparator` for Sorting by Different Criteria

You can create different classes that implement `Comparator<Person>` to sort `Person` objects by different criteria (for example, by age or by name).

```java
public class Person{
  private String name;
  private int age;
  public Person(String name, int age) { /* ... */ }
  @Override
  public String toString() { /* ... */ }
  public String getName() { return name; }
  public int getAge() { return age; }
}
```
```java
public class ComparePersonByAge implements Comparator<Person> {
  @Override
  public int compare(Person p1, Person p2) {
    return p1.getAge() - p2.getAge(); // Compare by age
  }
}
```
```java
public class ComparePersonByName implements Comparator<Person> {
  @Override
  public int compare(Person p1, Person p2) {
    return p1.getName().compareTo(p2.getName()); // Compare by name
  }
}
```
Using `Arrays.sort()` with a `Comparator`:

```java
Person[] arr = {
  new Person("Yosi", 27),
  new Person("Yael", 22),
  new Person("Mor", 25)
};
System.out.println("Before sorting: " + Arrays.toString(arr));
Arrays.sort(arr, new ComparePersonByName()); // Sort using Comparator by name
System.out.println("After sorting by name: " + Arrays.toString(arr));
Arrays.sort(arr, new ComparePersonByAge()); // Sort using Comparator by age
System.out.println("After sorting by age: " + Arrays.toString(arr));
```
console:
Before sorting: [{Yosi, 27}, {Yael, 22}, {Mor, 25}]
After sorting by name: [{Mor, 25}, {Yael, 22}, {Yosi, 27}]
After sorting by age: [{Yael, 22}, {Mor, 25}, {Yosi, 27}]

### 1.4 Exercise 3: Using `Comparator` with `Double.compare`

> [!example] Exercise **`Comparator` for Product Prices**
> Given code that defines a `Product` class and a `Comparator` named `PriceAscComparator` which sorts products in ascending order by price using `Double.compare`. What will happen when the following code is executed?

```java
> final class Product {
>   private final String name;
>   private final double price;
>   public Product(String name, double price) {
>     this.name = name;
>     this.price = price;
>   }
>   public String getName() { return name; }
>   public double getPrice() { return price; }
>   @Override
>   public String toString() {
>     return name + " ($" + price + ")";
>   }
> }
> class PriceAscComparator implements Comparator<Product> {
>   @Override
>   public int compare(Product p1, Product p2) {
>     return Double.compare(p1.getPrice(), p2.getPrice()); // Compare double prices
>   }
> }
> public class Main {
>   public static void main(String[] args) {
>     Product laptop = new Product("Laptop", 1200.00);
>     Product mouse = new Product("Mouse", 25.00);
>     Product keyboard = new Product("Keyboard", 75.00);
>     PriceAscComparator priceComp = new PriceAscComparator();
>     System.out.println(priceComp.compare(laptop, mouse)); // Laptop vs Mouse (1200 vs 25) -> positive
>     System.out.println(priceComp.compare(mouse, keyboard)); // Mouse vs Keyboard (25 vs 75) -> negative
>     System.out.println(priceComp.compare(keyboard, laptop)); // Keyboard vs Laptop (75 vs 1200) -> negative
>   }
> }
> ```

> [!NOTE] Explanation **Solution to Exercise 3**
> The output will display the results of the comparison between pairs of different products using the `Comparator`.
>
> console:
> (positive value)
> (negative value)
> (negative value)

### 1.5 Exercise 4: Implementing Java Interfaces

- Link to the exercise file was provided in the source.
- Link to the starter was provided in the source.
- Website to download libraries from github was provided in the source.

## 2 🧬 4. Object Cloning

- **Shallow Copy:** Creates a copy of the original object, but fields that are references to other objects still point to the same referenced objects as in the original object. Changes to the referenced objects will affect both copies (original and cloned).
- **Deep Copy:** Creates a completely new copy of the original object, including creating new copies for all objects that its fields refer to. Changes to the referenced objects will not affect the other copy.

### 2.1 Shallow Copy - Example with an Array of References

Copying an array of references (as in the first `Animal` array example) creates a shallow copy of the objects within the array. Both arrays refer to the same objects.

```java
public static void main(String[] args) {
  Animal[] animals = new Animal[3];
  animals[0] = new Cat("Pitzi", "Brown", 5.7);
  animals[1] = new Fish("Dagi", "gold");
  animals[2] = new Horse("Davi", "Black", 184);
  Animal[] newAnimals = new Animal[3];
  for (int i = 0; i < animals.length; i++) {
    newAnimals[i] = animals[i]; // Shallow copy of references
  }
  animals[0].setColor("blue"); // Changes the object referenced by both arrays
  System.out.println("Animals:");
  System.out.println(Arrays.toString(animals));
  System.out.println("New animals:");
  System.out.println(Arrays.toString(newAnimals));
}
```
console:
Animals:
[Cat: Pitzi, blue, 5.7, Fish: Dagi, gold, Horse: Davi, Black, 184]
New animals:
[Cat: Pitzi, blue, 5.7, Fish: Dagi, gold, Horse: Davi, Black, 184]

### 1.5 Deep Copy using a Copy Constructor

One way to perform a deep copy is to use a Copy Constructor in each class, which creates a new object and copies the values of the fields (and creates copies of referenced objects).

```java
// In each class (Cat, Fish, Horse):
// public Cat(Cat other) { ... deep copy logic ... }
// public Fish(Fish other) { ... deep copy logic ... }
// public Horse(Horse other) { ... deep copy logic ... }
```
```java
public static void main(String[] args) {
  Animal[] animals = new Animal[3];
  animals[0] = new Cat("Pitzi", "Brown", 5.7);
  animals[1] = new Fish("Dagi", "gold");
  animals[2] = new Horse("Davi", "Black", 184);
  Animal[] newAnimals = new Animal[3];
  for (int i = 0; i < animals.length; i++) {
    if (animals[i] instanceof Cat) {
      newAnimals[i] = new Cat((Cat)animals[i]); // Use copy constructor
    } else if (animals[i] instanceof Fish) {
      newAnimals[i] = new Fish((Fish)animals[i]);
    } else if (animals[i] instanceof Horse) {
      newAnimals[i] = new Horse((Horse)animals[i]);
    }
  }
  animals[0].setColor("blue"); // Only changes the original object
  System.out.println("Animals:");
  System.out.println(Arrays.toString(animals));
  System.out.println("New animals:");
  System.out.println(Arrays.toString(newAnimals));
}
```
console:
Animals:
[Cat: Pitzi, blue, 5.7, Fish: Dagi, gold, Horse: Davi, Black, 184]
New animals:
[Cat: Pitzi, Brown, 5.7, Fish: Dagi, gold, Horse: Davi, Black, 184]

### 1.6 Cloning using the `Cloneable` Interface and `clone()` Method

> [!note]
>  ==**To create a deep, real copy of an object that contains other objects, we need to implement clone for each of the objects separately.**==

> [!note] MUST IMPLEMENT IN ANY CLONE() METHOD
>  ==**Every class that wants to create a Clone() method, must follow these two:
> **==
> 1. implement `Cloneable` interface
> 2. implement `Clone()` method of `Object` class or create a custom `Clone()` method

> [!note] Definition **`Cloneable`**
> A marker interface in Java that has no methods. It is used to indicate that objects of this class are permitted to be cloned using the `Object.clone()` method. If a class does not implement `Cloneable` and its `clone()` method is called, a `CloneNotSupportedException` will be thrown.

> [!important] Formula **`Object.clone()` Method (Protected)**
> The `Object.clone()` method (defined in the `Object` class) performs a shallow copy by default. To perform a deep copy, you must override it in subclasses and explicitly handle the cloning of referenced fields.
> ```java
> protected native Object clone() throws CloneNotSupportedException;
> ```

```java
public abstract class Animal implements Cloneable { // Implement Cloneable
  private String name;
  private String color;
  public Animal(String name, String color) { /* ... */ }
  public Animal(Animal other) { /* ... */ }
  public String getColor() { /* ... */ }
  public void setColor(String color) { /* ... */ }
  @Override
  protected Animal clone() throws CloneNotSupportedException { // Override clone
    return (Animal) super.clone(); // Calls Object.clone()
  }
  @Override
  public String toString() { /* ... */ }
}
// Subclasses (Cat, Fish, Horse) may need to override clone() as well for deep copy if they have object fields.
```
Using the `clone()` method:

```java
public static void main(String[] args) {
  Animal[] animals = new Animal[3];
  animals[0] = new Cat("Pitzi", "Brown", 5.7);
  animals[1] = new Fish("Dagi", "gold");
  animals[2] = new Horse("Davi", "Black", 184);
  Animal[] newAnimals = new Animal[3];
  try {
    for (int i = 0; i < animals.length; i++) {
      newAnimals[i] = animals[i].clone(); // Use clone() - requires Cloneable
    }
  } catch (CloneNotSupportedException e) {
    e.printStackTrace();
  }
  animals[0].setColor("blue"); // Assumes clone() in Animal and subclasses handles deep copy
  System.out.println("Animals:");
  System.out.println(Arrays.toString(animals));
  System.out.println("New animals:");
  System.out.println(Arrays.toString(newAnimals));
}
```
console (assuming subclasses implement deep copy in their clone method):
Animals:
[Cat: Pitzi, blue, 5.7, Fish: Dagi, gold, Horse: Davi, Black, 184]
New animals:
[Cat: Pitzi, Brown, 5.7, Fish: Dagi, gold, Horse: Davi, Black, 184]

### 1.7 Exercise 5: Using `Cloneable` with Simple Classes

> [!example] Exercise **`Cloneable` for Classes with Primitive and `final` Fields**
> Given code that defines `Gadget` and `Tool` classes implementing `Cloneable` and overriding the `clone()` method. Both classes have `final` fields that are primitive types or `String`. What will happen when the code attempting to clone objects from them is executed?
> ```java
> class Gadget implements Cloneable {
>   private final String model;
>   private final int serialNumber;
>   public Gadget(String model, int serialNumber) {
>     this.model = model;
>     this.serialNumber = serialNumber;
>   }
>   @Override
>   protected Gadget clone() throws CloneNotSupportedException {
>     return (Gadget) super.clone(); // Default shallow copy works for final primitives/Strings
>   }
>   @Override
>   public String toString() {
>     return "Gadget [Model: " + model + ", S/N: " + serialNumber + "]";
>   }
> }
> class Tool implements Cloneable {
>   private final String type;
>   public Tool(String type) {
>     this.type = type;
>   }
>   @Override
>   protected Tool clone() throws CloneNotSupportedException {
>     return (Tool) super.clone(); // Default shallow copy works for final String
>   }
>   @Override
>   public String toString() {
>     return "Tool [Type: " + type + "]";
>   }
> }
> public class Main {
>   public static void main(String[] args) {
>     Gadget g1 = new Gadget("SmartPhone X", 1001);
>     Tool t1 = new Tool("Hammer");
>     System.out.println("Original Gadget: " + g1);
>     System.out.println("Original Tool: " + t1);
>     try {
>       Gadget g2 = g1.clone();
>       System.out.println("Cloned Gadget: " + g2);
>       Tool t2 = t1.clone();
>       System.out.println("Cloned Tool: " + t2);
>     } catch (CloneNotSupportedException e) {
>       System.out.println("Caught exception: “ + e.getMessage());
>       System.out.println("Type of exception: " + e.getClass().getName());
>     }
>   }
> }
> ```

> [!NOTE] Explanation **Solution to Exercise 5**
> Since the fields of the `Gadget` and `Tool` classes are primitive types (`int`) or `String` (which is immutable), the shallow copy performed by `super.clone()` (which invokes `Object.clone()`) is actually sufficient to create a logical copy of the objects. A `CloneNotSupportedException` will not be thrown because the `Cloneable` interface is implemented. The output will show the original and cloned objects.
>
> console:
> Original Gadget: Gadget [Model: SmartPhone X, S/N: 1001]
> Original Tool: Tool [Type: Hammer]
> Cloned Gadget: Gadget [Model: SmartPhone X, S/N: 1001]
> Cloned Tool: Tool [Type: Hammer]

## 2 📁 5. Program for Implementing Input/Output

- Link to the exercise file was provided in the source.
- Link to the starter was provided in the source.
- Website to download libraries from github was provided in the source.
- sdasdsa
	- dasdsa
		- dasdsa
			- dsadas
				- dsada

